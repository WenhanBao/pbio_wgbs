---
title: "Analyzing WGBS raw data with GPT-4 (Version 2)"
author: "Wenhan Bao"
date: "`r Sys.Date()`"
output: html_document
---

**For testing purpose, the GEO accession used is GSE107729. The following knit result is limited manually to first 20,000 sites for computation efficiency**

+ 3 control samples: GSM2877162, GSM2877167, GSM2877169

+ 3 schizophrenia patients: GSM2877163, GSM2877164, GSM2877165

**Testing Version: GPT4 - Mar23**

## 1. Data Processing

Prompt: 

Write a R code. Read the WGBS data from the “WGBS_data_control_sch” directory by fread(). There are 4 columns for each data, representing chromosome info, position info, methylation info and coverage info. Delete the row if the coverage info is equal to zero. Create a new beta value column which is calculated by methylation info/coverage info. set the row name in the format of “chromosome info : position info”. Rename the beta value column by the file name(first 10 strings). Combine all the previous data frames by row name and only preserve common row name. Print first 10 rows. 
(Don’t use reduce() function, remember to retain the row names as a separate column before combining the data frames, and as.data.frame() to the combined data)

```{r message=FALSE, warning=FALSE}
library(data.table)

# Read files from the directory
dir_path <- "WGBS_data_control_sch"
files <- list.files(dir_path, full.names = TRUE)

# Initialize an empty list to store data frames
data_frames <- list()

# Iterate through the files and process each one
for (file in files) {
  # Read the file using fread
  data <- fread(file)

  # Set column names
  colnames(data) <- c("chromosome", "position", "methylation", "coverage")

  # Remove rows with coverage info equal to zero
  data <- data[coverage != 0, ]
  
  # Calculate beta value and create a new column
  data$beta_value <- data$methylation / data$coverage

  # Set row names in the required format
  data$row_name <- paste(data$chromosome, data$position, sep=":")

  # Rename the beta value column as the file name (first 10 characters)
  new_col_name <- substr(basename(file), 1, 10)
  colnames(data)[which(colnames(data) == "beta_value")] <- new_col_name

  # Select only the required columns and add the data frame to the list
  data_frames[[length(data_frames) + 1]] <- data[, c("row_name", new_col_name), with = FALSE]
}

# Combine all data frames by row names and preserve only common row names (without using Reduce)
combined_data <- data_frames[[1]]
for (i in 2:length(data_frames)) {
  combined_data <- merge(combined_data, data_frames[[i]], by = "row_name", all = FALSE)
}

# Set row names for the combined data frame
combined_data <- as.data.frame(combined_data)
row.names(combined_data) <- combined_data$row_name
combined_data$row_name <- NULL

# Print first 10 rows of the combined data frame
head(combined_data, 10)
```

## 2.PCA

Prompt: 

Step 1: Continue analysis using the combined data. Transpose the data frame. Filter out the columns if all the values are equal to zero. (Note that do not need to reset rowname and colname when transpose the data)

```{r}
# Transpose the data frame
combined_data_t <- as.data.frame(t(combined_data))

# Filter out columns with all values equal to zero
combined_data_t_filtered <- combined_data_t[, !apply(combined_data_t, 2, function(x) all(x == 0))]
```

Step 2: Then calculate the mean and standard deviation for each columns. Fit a linear model of the standard deviation against the mean and calculate the residual for each columns. Only preserve the columns with positive residual. If there are more than 5,000 columns with positive residual, only retain 5,000 columns with the higher  residual. Otherwise, retain all columns with positive residual.

```{r}
# Calculate the mean and standard deviation for each column
column_means <- colMeans(combined_data_t_filtered)
column_sds <- apply(combined_data_t_filtered, 2, sd)

# Fit a linear model of the standard deviation against the mean
lm_model <- lm(column_sds ~ column_means)

# Calculate the residuals for each column
residuals <- lm_model$residuals

# Filter columns based on the residuals
positive_residual_columns <- names(residuals[residuals > 0])

# Retain top 5,000 columns with higher residuals (if more than 5,000 columns have positive residual)
if (length(positive_residual_columns) > 5000) {
  top_5000_residual_columns <- names(sort(residuals[residuals > 0], decreasing = TRUE))[1:5000]
  combined_data_t_filtered <- combined_data_t_filtered[, top_5000_residual_columns]
} else {
  combined_data_t_filtered <- combined_data_t_filtered[, positive_residual_columns]
}
```

Step 3: Then conduct PCA to filtered data. Use ggplot2 to plot the samples using the first two principal components. We have two groups of samples. The Control group is GSM2877162, GSM2877167, GSM2877169. The schizophrenia group is GSM2877163, GSM2877164, GSM2877165. In the plot, use yellow and blue color to separate these two groups. Set the plot title as "Principal component analysis". (Note that need to scale and remember to mark yellow as control and blue as schizophrenia in the legend of the plot)

```{r}
# Load necessary libraries
library(ggplot2)

# Perform PCA on the filtered data with scaling
pca_result_filtered <- prcomp(combined_data_t_filtered, scale. = TRUE)

# Prepare data for ggplot2
pca_data_filtered <- as.data.frame(pca_result_filtered$x)
pca_data_filtered$sample <- rownames(pca_data_filtered)
pca_data_filtered$group <- ifelse(pca_data_filtered$sample %in% c("GSM2877162", "GSM2877167", "GSM2877169"), "Control", "Schizophrenia")

# Plot PCA results using ggplot2
pca_plot_filtered <- ggplot(pca_data_filtered, aes(x = PC1, y = PC2, color = group, label = sample)) +
  geom_point(size = 3) +
  theme_minimal() +
  ggtitle("Principal component analysis") +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(x = "Principal Component 1", y = "Principal Component 2") +
  scale_color_manual(values = c("Control" = "yellow", "Schizophrenia" = "blue"))

print(pca_plot_filtered)
```

## 3. Identify differentially methylated regions

Prompt:

Step 1: Re-read the data sets. Generate one matrix which would combine all the coverage info together. Generate another matrix which would combine all the methylation info. Generate a vector of position info. Generate a vector of chromosome info. Generate a vector of sample name(First 10 strings of the file name)

```{r message=FALSE, warning=FALSE}
library(data.table)

# Read files from the directory
dir_path <- "WGBS_data_control_sch"
files <- list.files(dir_path, full.names = TRUE)

# Initialize empty matrices for coverage and methylation info
coverage_matrix <- NULL
methylation_matrix <- NULL

# Initialize empty vectors for position, chromosome info, and sample names
position_vector <- NULL
chromosome_vector <- NULL
sample_names <- NULL

# Iterate through the files and process each one
for (file in files) {
  # Read the file using fread
  data <- fread(file)

  # Set column names
  colnames(data) <- c("chromosome", "position", "methylation", "coverage")

  # Remove rows with coverage info equal to zero
  data <- data[coverage != 0, ]

  # Add coverage and methylation info to the respective matrices
  coverage_matrix <- cbind(coverage_matrix, data$coverage)
  methylation_matrix <- cbind(methylation_matrix, data$methylation)

  # Add position and chromosome info to the respective vectors
  # (only if they haven't been populated yet)
  if (is.null(position_vector)) {
    position_vector <- data$position
  }
  if (is.null(chromosome_vector)) {
    chromosome_vector <- data$chromosome
  }

  # Add sample name to the sample names vector
  sample_name <- substr(basename(file), 1, 10)
  sample_names <- c(sample_names, sample_name)
}
```

Step 2: Then create a BSseq object. Use the matrix and vectors generated as input.

```{r message=FALSE, warning=FALSE}
# Install the bsseq and SummarizedExperiment packages if not already installed
library(bsseq)
library(SummarizedExperiment)

# Create the BSseq object
BSobj <- BSseq(chr = chromosome_vector,
               pos = position_vector,
               M = methylation_matrix,
               Cov = coverage_matrix,
               sampleNames = sample_names)

# Print the BSseq object
print(BSobj)
```

Step 3: Then BSmooth the BSseq object

```{r message=FALSE, warning=FALSE}
# Perform BSmooth normalization on the BSseq object
BSmoothObj <- BSmooth(BSobj)

# Print the BSmooth BSseq object
print(BSmoothObj)
```

Step 4: Get the coverage from the BSmooth normalized BSseq object, then identify the loci that fulfill the coverage criteria for both groups (Specifically, it identifies the loci for which at least two samples from each group have a coverage of 2 or higher). Print the number of loci that fulfill the criteria and subset the BSmooth normalized BSseq object to keep only the selected loci. Finally, print the filtered BSmooth normalized BSseq object.

```{r message=FALSE, warning=FALSE}
# Get the coverage from the BSmooth normalized BSseq object
BS_cov <- getCoverage(BSmoothObj)

# Identify the loci that fulfill the coverage criteria for both groups
keepLoci <- which(rowSums(BS_cov[, c("GSM2877162", "GSM2877167", "GSM2877169")] >= 2) >= 2 &
                   rowSums(BS_cov[, c("GSM2877163", "GSM2877164", "GSM2877165")] >= 2) >= 2)

# Print the number of loci that fulfill the criteria
cat("Number of loci to keep:", length(keepLoci), "\n")

# Subset the BSmooth normalized BSseq object to keep only the selected loci
BSmoothObj_filtered <- BSmoothObj[keepLoci,]

# Print the filtered BSmooth normalized BSseq object
print(BSmoothObj_filtered)
```

Step 5: Then compute the t-statistics by BSmooth.tstat(). In this function, set the group 1 as all schizophrenia samples and group 2 as all control samples. Also, set the group 2 as estimate.var and set local.correct as TRUE. (Note that the first argument is BSseq not bsseq which is case sensitive)

```{r message=FALSE, warning=FALSE}
# Compute the t-statistics
tstat_result <- BSmooth.tstat(BSseq = BSmoothObj_filtered,
                              group1 = c("GSM2877163", "GSM2877164", "GSM2877165"),
                              group2 = c("GSM2877162", "GSM2877167", "GSM2877169"),
                              estimate.var = "group2",
                              local.correct = TRUE)

# Print the t-statistics result
print(tstat_result)
```

Step 6: Then compute differentially methylated regions(DMRs) by thresholding the t-statistics by dmrFinder() function. Try a cutoff of 1.(Note that specify the argument cutoff = (-1,1)).

```{r message=FALSE, warning=FALSE}
# Compute differentially methylated regions (DMRs) with a cutoff of (-1, 1)
DMRs <- dmrFinder(tstat_result, cutoff = c(-1, 1))

# Print the DMRs
print(DMRs)
```

Step 7: Then filter out DMRs that do not have at least 3 CpGs in them and at least a mean difference (across the DMR) in methylation between control and schizophrenia of at least 0.1 by subset() function. (Note that n in the DMRs is the number of CpGs and the meanDiff the DMRs is the mean methylation difference for each DMR)

```{r message=FALSE, warning=FALSE}
# Filter DMRs with at least 3 CpGs and a mean methylation difference of at least 0.1 using subset()
filtered_DMRs <- subset(DMRs, n >= 3 & abs(meanDiff) >= 0.1)

# Print the filtered DMRs
print(filtered_DMRs)
```

Step 8: Next, create a data frame. Set the row name of this data frame as sample names by sampleNames() and add a `col` column where the control group is “red” and schizophrenia is “blue”. Set this data frame as the pData of filtered BSmooth object. (Note that there is no data frame of pData now so create a new one)

```{r message=FALSE, warning=FALSE}
# Create a new data frame for pData
pData_df <- data.frame(SampleName = sampleNames(BSmoothObj_filtered))

# Set row names as sample names
rownames(pData_df) <- pData_df$SampleName

# Define control and schizophrenia sample names
control_samples <- c("GSM2877162", "GSM2877167", "GSM2877169")
schizophrenia_samples <- c("GSM2877163", "GSM2877164", "GSM2877165")

# Add a `col` column for control and schizophrenia samples
pData_df$col <- ifelse(rownames(pData_df) %in% control_samples, "red", "blue")

# Set the pData of the filtered BSmooth object
pData(BSmoothObj_filtered) <- pData_df

# Print the updated pData data frame
print(pData(BSmoothObj_filtered))
```

Step 9: Then plot the DMRs by plotManyRegions(). Plot the top 5. In this function, specify extend = 5000 and filtered DMRs as addRegions. Set the plot name as "Identify differentially methylated regions" by specifying main. (Don’t specify pData)

```{r message=FALSE, warning=FALSE}
# Select the top 5 DMRs
top5_DMRs <- head(subset(filtered_DMRs, n >= 3 & abs(meanDiff) >= 0.1), 5)

# Use plotManyRegions to plot the top 5 DMRs with the specified title
plotManyRegions(BSmoothObj_filtered, regions = top5_DMRs, extend = 5000, addRegions = filtered_DMRs, main = "Identify differentially methylated regions")
```
